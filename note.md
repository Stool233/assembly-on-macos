.equ定义字面量
    类似C语言中的#define定义的宏


局部变量
    栈
        在操作系统基础中，我们谈到，在一个程序运行的时候，系统会自动给这个程序分配一个栈区。这个栈区和数据结构中所说的栈类似，也支持压栈和弹栈的操作。栈区在逻辑地址空间里是一块连续的空间，栈底是固定的，每次压栈，都会使栈顶向逻辑地址减小的方向移动。

        rsp寄存器。从它的名字就可以看出来，stack pointer, 它存储的值永远是栈顶的地址，所以它又被叫做栈顶指针。
            我们可以用(%rsp)来获取栈顶存储的值，
            通过a(%rsp), 其中a是任何一个整数，来获取地址是rsp存储的值加a处的内存单元的值。
                比如说，2(%rsp)就是栈顶上方（逻辑地址增大方向）2个字节处的值，
                -2(%rsp)就是栈顶下方（逻辑地址减小方向）2个字节处的值。

        在汇编语言中，压栈和弹栈的助记符分别是push和pop. 
            这两个操作均有一个操作数。
            push的操作是将栈顶指针向下移动（也就是将rsp内的值减小），并将移动后rsp对应位置内存区域的值赋为其操作数，而pop则相反。
            这里“向下移动”的距离是根据push后面跟着的字母决定的，如pushq就是把rsp内的值减8.
        
        此外，如果是想获得栈顶的值，而不弹栈，可以直接用mov来实现。
            如popq	%rax是将栈顶的8个字节内存储的值赋给rax, 并且栈顶指针向上移动8个字节。
            而movq	(%rsp), %rax则是只将栈顶的8个字节内存储的值赋给rax, 不涉及栈顶指针的移动。
            而如果只想弹栈却不想赋值，那么直接对rsp进行add即可。
                如想把栈顶的8个字节的数据弹栈，就直接addq	$8, %rsp.

        同时，对于push而言，如果我们一下子准备把许多值压入栈内，那么可以先用sub指令减小rsp, 再用mov移动。比如说：
        
        ```
        # method 1
        pushq	$0x114514
        pushq	$0x1919
        pushq	$0x810

        # method 2
        subq	$24, %rsp
        movq	$0x114514, 16(%rsp)
        movq	$0x1919, 8(%rsp)
        movq	$0x810, (%rsp)
        ```


        方法一和方法二的最终效果是一样的。但是，我们建议使用方法二，也就是“先sub, 再mov”，因为这样更高效。

    使用局部变量
        使用局部变量非常简单，就是将局部变量放到栈上，然后使用的时候直接去访问栈上对应的地址空间就行。然后在返回之前，把栈恢复即可。

        但是，这里有一个常用的技巧。像上面的例子中写的，我们是通过对rsp中存储的地址加偏移量去访问局部变量，但是，如果我们之后又有了压栈、弹栈的操作，那么，偏移量就会改变。这种不稳定性十分不利于我们编程。
            因此，我们又用了另一个寄存器rbp来解决这个问题。
                rbp, 顾名思义，base pointer, 基地址指针，一般是用来使用偏移量寻址的。
                我们使用的技巧是，先将rbp push进栈（之所以保留我会在后面的调用约定里说到），然后利用之前的手法对rsp sub. 
                然后，利用rbp的偏移量来引用局部变量。
                最后在返回前，将rbp赋值给rsp, 此时栈顶指针指向的是最初对rbppush之后的位置，然后将栈顶pop出来给rbp，最后返回。
        
        [参考](https://github.com/Evian-Zhang/Assembly-on-macOS/blob/master/macOS%E4%B8%8A%E7%9A%84%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.md)

